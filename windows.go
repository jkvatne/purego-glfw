package glfw

import (
	"errors"
	"fmt"
	"golang.design/x/clipboard"
	"golang.org/x/sys/windows"
	"syscall"
	"unsafe"
)

type PIXELFORMATDESCRIPTOR = struct {
	nSize           uint16
	nVersion        uint16
	dwFlags         uint32
	iPixelType      uint8
	cColorBits      uint8
	cRedBits        uint8
	cRedShift       uint8
	cGreenBits      uint8
	cGreenShift     uint8
	cBlueBits       uint8
	cBlueShift      uint8
	cAlphaBits      uint8
	cAlphaShift     uint8
	cAccumBits      uint8
	cAccumRedBits   uint8
	cAccumGreenBits uint8
	cAccumBlueBits  uint8
	cAccumAlphaBits uint8
	cDepthBits      uint8
	cStencilBits    uint8
	cAuxBuffers     uint8
	iLayerType      uint8
	bReserved       uint8
	dwLayerMask     uint32
	dwVisibleMask   uint32
	dwDamageMask    uint32
}

const (
	PFD_DRAW_TO_WINDOW = 0x04
	PFD_SUPPORT_OPENGL = 0x20
	PFD_DOUBLEBUFFER   = 0x01
	PFD_TYPE_RGBA      = 0x00
)
const (
	SWP_NOSIZE         = 0x0001
	SWP_NOMOVE         = 0x0002
	SWP_NOZORDER       = 0x0004
	SWP_NOREDRAW       = 0x0008
	SWP_NOACTIVATE     = 0x0010
	SWP_FRAMECHANGED   = 0x0020
	SWP_SHOWWINDOW     = 0x0040
	SWP_HIDEWINDOW     = 0x0080
	SWP_NOCOPYBITS     = 0x0100
	SWP_NOOWNERZORDER  = 0x0200
	SWP_NOSENDCHANGING = 0x0400
)

// Internal cursor types
const (
	IDC_ARROW       = 32512 // Standard arrow
	IDC_IBEAM       = 32513 // I-beam
	IDC_WAIT        = 32514 // Hour
	IDC_CROSS       = 32515 // Crosshair
	IDC_UPARROW     = 32516 // Vertical arrow
	IDC_SIZENWSE    = 32642 // Double-pointed arrow pointing northwest and southeast
	IDC_SIZENESW    = 32643 // Double-pointed arrow pointing northeast and southwest
	IDC_SIZEWE      = 32644 // Double-pointed arrow pointing west and east
	IDC_SIZENS      = 32645 // Double-pointed arrow pointing north and south
	IDC_SIZEALL     = 32646 // Four-pointed arrow pointing north, south, east, and west
	IDC_NO          = 32648 // Slashed circle
	IDC_HAND        = 32649 // Hand
	IDC_APPSTARTING = 32650 // Standard arrow and small hourglass
	IDC_HELP        = 32651 // Arrow and question mark
)

var resources struct {
	handle syscall.Handle
	class  uint16
	cursor syscall.Handle
}

func glfwPollEvents() {
	var msg Msg
	for PeekMessage(&msg, 0, 0, 0, PM_REMOVE) {
		if msg.Message == WM_QUIT {
			window := _glfw.windowListHead
			for window != nil {
				glfwInputWindowCloseRequest(window)
				window = window.next
			}
		} else {
			TranslateMessage(&msg)
			DispatchMessage(&msg)
		}
	}

	// HACK: Release modifier keys that the system did not emit KEYUP for
	// NOTE: Shift keys on Windows tend to "stick" when both are pressed as
	//       no key up message is generated by the first key release
	// NOTE: Windows key is not reported as released by the Win+V hotkey
	//       Other Win hotkeys are handled implicitly by _glfwInputWindowFocus
	//       because they change the input focus
	// NOTE: The other half of this is in the WM_*KEY* handler in windowProc
	handle := GetActiveWindow()
	if handle != 0 {
		window := (*Window)(unsafe.Pointer(GetProp(handle, "GLFW")))
		if window != nil {
			keys := [4][2]Key{{VK_LSHIFT, KeyLeftShift}, {VK_RSHIFT, KeyRightShift}, {VK_LWIN, KeyLeftSuper}, {VK_RWIN, KeyRightSuper}}
			for i := 0; i < 4; i++ {
				vk := keys[i][0]
				key := keys[i][1]
				scancode := _glfw.win32.scancodes[key]
				if (GetKeyState(int(vk))&0x8000 != 0) || (window.keys[key] != GLFW_PRESS) {
					continue
				}
				glfwInputKey(window, key, int(scancode), GLFW_RELEASE, getKeyMods())
			}
		}
	}
	/*
		window := _glfw.disabledCursorWindow
		if window != nil {
			var width, height int
			// TODO _glfwPlatformGetWindowSize(window, &width, &height);
			// NOTE: Re-center the cursor only if it has moved since the last call,
			//       to avoid breaking glfwWaitEvents with WM_MOUSEMOVE
			if window.Win32.lastCursorPosX != width/2 || window.Win32.lastCursorPosY != height/2 {
				// TODO _glfwPlatformSetCursorPos(window, width / 2, height / 2);
			}
		}*/
}

func getWindowStyle(window *_GLFWwindow) uint32 {
	var style uint32 = WS_CLIPSIBLINGS | WS_CLIPCHILDREN
	if window.monitor != nil {
		style |= WS_POPUP
	} else {
		style |= WS_SYSMENU | WS_MINIMIZEBOX
		if window.decorated {
			style |= WS_CAPTION
		}
		if window.resizable {
			style |= WS_MAXIMIZEBOX | WS_THICKFRAME
		} else {
			style |= WS_POPUP
		}
	}
	return style
}

func getWindowExStyle(w *_GLFWwindow) uint32 {
	var style uint32 = WS_EX_APPWINDOW
	if w.monitor != nil || w.floating {
		style |= WS_EX_TOPMOST
	}
	return style
}

func _glfwRegisterWindowClassWin32() error {
	wcls := WndClassEx{
		CbSize:        uint32(unsafe.Sizeof(WndClassEx{})),
		Style:         CS_HREDRAW | CS_VREDRAW | CS_OWNDC,
		LpfnWndProc:   syscall.NewCallback(windowProc),
		HInstance:     _glfw.instance,
		HIcon:         0,
		LpszClassName: syscall.StringToUTF16Ptr("GLFW"),
	}
	// TODO Load user-provided icon if available
	// wcls.hIcon = LoadImageW(GetModuleHandleW(NULL),"GLFW_ICON", IMAGE_ICON,	0, 0, LR_DEFAULTSIZE | LR_SHARED);
	// if wcls.hIcon==0 {
	// No user-provided icon found, load default icon
	// wcls.hIcon = LoadImageW(NULL, IDI_APPLICATION, IMAGE_ICON,	0, 0, LR_DEFAULTSIZE | LR_SHARED);
	// }
	var err error
	_glfw.class, err = RegisterClassEx(&wcls)
	return err
}

func createNativeWindow(window *_GLFWwindow, wndconfig *_GLFWwndconfig, fbconfig *_GLFWfbconfig) error {
	var err error
	var frameX, frameY, frameWidth, frameHeight int32
	style := getWindowStyle(window)
	exStyle := getWindowExStyle(window)

	if _glfw.win32.mainWindowClass == 0 {
		err = _glfwRegisterWindowClassWin32()
		if err != nil {
			panic(err)
		}
		_glfw.win32.mainWindowClass = _glfw.class
	}
	if window.monitor != nil {
		mi := GetMonitorInfo(window.monitor.hMonitor)
		// NOTE: This window placement is temporary
		frameX = mi.RcMonitor.Left
		frameY = mi.RcMonitor.Top
		frameWidth = mi.RcMonitor.Right - mi.RcMonitor.Left
		frameHeight = mi.RcMonitor.Bottom - mi.RcMonitor.Top
	} else {
		rect := RECT{0, 0, int32(wndconfig.width), int32(wndconfig.height)}
		window.Win32.maximized = wndconfig.maximized
		if wndconfig.maximized {
			style |= WS_MAXIMIZE
		}
		AdjustWindowRectEx(&rect, style, 0, exStyle)
		if wndconfig.xpos == GLFW_ANY_POSISTION && wndconfig.ypos == GLFW_ANY_POSISTION {
			frameX = CW_USEDEFAULT
			frameY = CW_USEDEFAULT
		} else {
			frameX = int32(wndconfig.xpos) + rect.Left
			frameY = int32(wndconfig.ypos) + rect.Top
		}
		frameWidth = rect.Right - rect.Left
		frameHeight = rect.Bottom - rect.Top
	}

	window.Win32.handle, err = CreateWindowEx(
		exStyle,
		_glfw.class,
		wndconfig.title,
		style,
		frameX, frameY,
		frameWidth, frameHeight,
		0, // No parent
		0, // No menu
		_glfw.win32.instance,
		uintptr(unsafe.Pointer(wndconfig)))

	SetProp(HANDLE(window.Win32.handle), "GLFW", uintptr(unsafe.Pointer(window)))
	return err
}

// Destroy destroys the specified window and its context. On calling this
// function, no further callbacks will be called for that window.
//
// This function may only be called from the main thread.
func glfwDestroyWindow(w *Window) {
	w.windowCloseCallback = nil
	w.refreshCallback = nil
	w.charCallback = nil
	w.keyCallback = nil
	w.focusCallback = nil
	w.scrollCallback = nil
	w.sizeCallback = nil
	w.dropCallback = nil
	w.contentScaleCallback = nil
	if uintptr(unsafe.Pointer(w)) == glfwPlatformGetTls(&_glfw.contextSlot) {
		glfwMakeContextCurrent(nil)
	}
	DestroyWindow(w.Win32.handle)
	// Unlink window from global linked list
	prev := &_glfw.windowListHead
	for *prev != w {
		prev = &((*prev).next)
	}
	*prev = w.next
	w.Win32.handle = 0
}

func glfwTerminate() {
	/* TODO
	   if (_glfw.Win32.deviceNotificationHandle) {
	   	UnregisterDeviceNotification(_glfw.Win32.deviceNotificationHandle);
	   }
	*/
	DestroyWindow(_glfw.win32.helperWindowHandle)
	_glfw.win32.helperWindowHandle = 0

	if _glfw.win32.mainWindowClass != 0 {
		UnregisterClass(_glfw.win32.mainWindowClass, _glfw.win32.instance)
		_glfw.win32.mainWindowClass = 0
	}
}

func glfwPlatformInit() error {
	var err error
	createKeyTables()
	SetProcessDpiAwareness()
	_glfw.instance, err = GetModuleHandle()
	if err != nil {
		return fmt.Errorf("glfw platform init failed %v ", err.Error())
	}
	err = createHelperWindow()
	if err != nil {
		return err
	}
	glfwPollMonitors()
	glfwDefaultWindowHints()
	_glfw.initialized = true
	return nil
}

func glfwPlatformCreateWindow(window *_GLFWwindow, wndconfig *_GLFWwndconfig, ctxconfig *_GLFWctxconfig, fbconfig *_GLFWfbconfig) error {
	err := createNativeWindow(window, wndconfig, fbconfig)
	if err != nil {
		return err
	}
	if ctxconfig.client != GLFW_NO_API {
		if err := _glfwInitWGL(); err != nil {
			return fmt.Errorf("_glfwInitWGL error %v", err.Error())
		}
		if err := glfwCreateContextWGL(window, ctxconfig, fbconfig); err != nil {
			return fmt.Errorf("glfwCreateContextWGL error %v", err.Error())
		}
		if err := _glfwRefreshContextAttribs(window, ctxconfig); err != nil {
			return err
		}
	}
	if window.monitor != nil {
		glfwShowWindow(window)
		glfwFocusWindow(window)
		acquireMonitor(window)
		fitToMonitor(window)
		if wndconfig.centerCursor {
			// TODO  _glfwCenterCursorInContentArea(window)
		}
	} else if wndconfig.visible {
		glfwShowWindow(window)
		if wndconfig.focused {
			glfwFocusWindow(window)
		}
	}
	return nil
}

func glfwCreateWindow(width, height int, title string, monitor *Monitor, share *_GLFWwindow) (*_GLFWwindow, error) {

	if width <= 0 || height <= 0 {
		return nil, fmt.Errorf("invalid width/heigth")
	}

	fbconfig := _glfw.hints.framebuffer
	ctxconfig := _glfw.hints.context
	wndconfig := _glfw.hints.window
	wndconfig.width = width
	wndconfig.height = height

	wndconfig.title = title
	ctxconfig.share = share
	if glfwIsValidContextConfig(&ctxconfig) != nil {
		return nil, fmt.Errorf("glfw context config is invalid: %v", ctxconfig)
	}

	window := &_GLFWwindow{}
	window.context = &_GLFWcontext{}
	window.next = _glfw.windowListHead
	_glfw.windowListHead = window

	window.videoMode.Width = width
	window.videoMode.Height = height
	window.videoMode.RedBits = fbconfig.redBits
	window.videoMode.GreenBits = fbconfig.greenBits
	window.videoMode.BlueBits = fbconfig.blueBits
	window.videoMode.RefreshRate = _glfw.hints.refreshRate

	window.monitor = monitor
	window.resizable = wndconfig.resizable
	window.decorated = wndconfig.decorated
	window.autoIconify = wndconfig.autoIconify
	window.floating = wndconfig.floating
	window.focusOnShow = wndconfig.focusOnShow
	window.cursorMode = GLFW_CURSOR_NORMAL
	window.doublebuffer = fbconfig.doublebuffer
	window.minwidth = GLFW_DONT_CARE
	window.minheight = GLFW_DONT_CARE
	window.maxwidth = GLFW_DONT_CARE
	window.maxheight = GLFW_DONT_CARE
	window.numer = GLFW_DONT_CARE
	window.denom = GLFW_DONT_CARE

	if err := glfwPlatformCreateWindow(window, &wndconfig, &ctxconfig, &fbconfig); err != nil {
		// glfwDestroyWindow(window)
		return nil, fmt.Errorf("Error creating window, %v", err.Error())
	}
	return window, nil
}

func glfwDefaultWindowHints() {
	_glfw.hints.context.client = GLFW_OPENGL_API
	_glfw.hints.context.source = GLFW_NATIVE_CONTEXT_API
	_glfw.hints.context.major = 1
	_glfw.hints.context.minor = 0
	// The default is a focused, visible, resizable window with decorations
	_glfw.hints.window.resizable = true
	_glfw.hints.window.visible = true
	_glfw.hints.window.decorated = true
	_glfw.hints.window.focused = true
	_glfw.hints.window.autoIconify = true
	_glfw.hints.window.centerCursor = true
	_glfw.hints.window.focusOnShow = true
	// The default is 24 bits of color, 24 bits of depth and 8 bits of stencil, double buffered
	_glfw.hints.framebuffer.redBits = 8
	_glfw.hints.framebuffer.greenBits = 8
	_glfw.hints.framebuffer.blueBits = 8
	_glfw.hints.framebuffer.alphaBits = 8
	_glfw.hints.framebuffer.depthBits = 24
	_glfw.hints.framebuffer.stencilBits = 8
	_glfw.hints.framebuffer.doublebuffer = true
	// The default is to select the highest available refresh rate
	_glfw.hints.refreshRate = GLFW_DONT_CARE
	// The default is to use full Retina resolution framebuffers
	_glfw.hints.window.ns.retina = true
}

func helperWindowProc(hwnd syscall.Handle, msg uint32, wParam, lParam uintptr) uintptr {
	/*	switch msg	{
		case WM_DISPLAYCHANGE:
		    _glfwPollMonitorsWin32();
		case WM_DEVICECHANGE:
			if (wParam == DBT_DEVICEARRIVAL) {
				DEV_BROADCAST_HDR* dbh = (DEV_BROADCAST_HDR*) lParam;
				if (dbh && dbh->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE)
				_glfwDetectJoystickConnectionWin32();
			} else if (wParam == DBT_DEVICEREMOVECOMPLETE)	{
				DEV_BROADCAST_HDR* dbh = (DEV_BROADCAST_HDR*) lParam;
				if (dbh && dbh->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE) {
					_glfwDetectJoystickDisconnectionWin32();
				}
			}

		}
	*/
	r1, _, _ := _DefWindowProc.Call(uintptr(hwnd), uintptr(msg), wParam, lParam)
	return r1
}

func glfwShowWindow(w *_GLFWwindow) {
	mode := windows.SW_NORMAL
	if w.Win32.iconified {
		mode = windows.SW_MINIMIZE
	} else if w.Win32.maximized {
		mode = windows.SW_MAXIMIZE
	}
	_, _, err := _ShowWindow.Call(uintptr(w.Win32.handle), uintptr(mode))
	if err != nil && !errors.Is(err, syscall.Errno(0)) {
		panic("ShowWindow failed, " + err.Error())
	}
}

func createHelperWindow() error {
	var err error
	var wc WndClassEx
	wc.CbSize = uint32(unsafe.Sizeof(wc))
	wc.Style = CS_OWNDC
	wc.LpfnWndProc = syscall.NewCallback(helperWindowProc)
	wc.HInstance = _glfw.instance
	wc.LpszClassName = syscall.StringToUTF16Ptr("GLFW3 Helper")

	_glfw.win32.helperWindowClass, err = RegisterClassEx(&wc)
	if _glfw.win32.helperWindowClass == 0 || err != nil {
		panic("Win32: Failed to register helper window class")
	}
	_glfw.win32.helperWindowHandle, err =
		CreateWindowEx(WS_OVERLAPPED,
			_glfw.win32.helperWindowClass,
			"Helper window",
			WS_OVERLAPPED|WS_CLIPSIBLINGS|WS_CLIPCHILDREN,
			0, 0, 500, 500,
			0, 0,
			resources.handle,
			0)

	if _glfw.win32.helperWindowHandle == 0 || err != nil {
		panic("Win32: Failed to create helper window")
	}
	_, _, err = _ShowWindow.Call(uintptr(_glfw.win32.helperWindowHandle), windows.SW_HIDE)
	if err != nil && !errors.Is(err, syscall.Errno(0)) {
		return err
	}

	// TODO Register for HID device notifications
	/*		dbi DEV_BROADCAST_DEVICEINTERFACE_W
			ZeroMemory(&dbi, sizeof(dbi));
			dbi.dbcc_size = sizeof(dbi);
			dbi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
			dbi.dbcc_classguid = GUID_DEVINTERFACE_HID;
			_glfw.win32.deviceNotificationHandle =	RegisterDeviceNotificationW(_glfw.win32.helperWindowHandle,
					(DEV_BROADCAST_HDR*) &dbi,	DEVICE_NOTIFY_WINDOW_HANDLE);
		}*/
	var msg Msg
	for PeekMessage(&msg, _glfw.win32.helperWindowHandle, 0, 0, PM_REMOVE) {
		TranslateMessage(&msg)
		DispatchMessage(&msg)
	}
	return nil
}

func glfwGetWindowFrameSize(window *_GLFWwindow, left, top, right, bottom *int) {
	var rect RECT
	var width, height int
	glfwGetWindowSize(window, &width, &height)
	rect.Right = int32(width)
	rect.Bottom = int32(height)
	dpi := GetDpiForWindow(window.Win32.handle)
	AdjustWindowRect(&rect, getWindowStyle(window), 0, getWindowExStyle(window), dpi, "glfwGetWindowFrameSize")
	*left = int(-rect.Left)
	*top = int(-rect.Top)
	*right = int(rect.Right) - width
	*bottom = int(rect.Bottom) - height
}

func screenToClient(handle syscall.Handle, p *POINT) {
	_, _, err := _ScreenToClient.Call(uintptr(handle), uintptr(unsafe.Pointer(p)))
	if !errors.Is(err, syscall.Errno(0)) {
		panic("GetCursorPos failed, " + err.Error())
	}
}

func glfwGetCursorPos(w *_GLFWwindow, x *int, y *int) {
	if w.cursorMode == GLFW_CURSOR_DISABLED {
		*x = int(w.virtualCursorPosX)
		*y = int(w.virtualCursorPosY)
	} else {
		var pos POINT
		_, _, err := _GetCursorPos.Call(uintptr(unsafe.Pointer(&pos)))
		if !errors.Is(err, syscall.Errno(0)) {
			// if we get an error (typical error 5, access denied, return something way off.
			*x = -32767
			*y = -32767
			return
		}
		screenToClient(w.Win32.handle, &pos)
		*x = int(pos.X)
		*y = int(pos.Y)
	}
}

func glfwGetWindowSize(window *_GLFWwindow, width *int, height *int) {
	var area RECT
	_, _, err := _GetClientRect.Call(uintptr(unsafe.Pointer(window.Win32.handle)), uintptr(unsafe.Pointer(&area)))
	if !errors.Is(err, syscall.Errno(0)) {
		panic(err)
	}
	// GetClientRect(window->win32.hMonitor, &area);
	*width = int(area.Right)
	*height = int(area.Bottom)
}

// GetClipboardString returns the contents of the system clipboard, if it
// contains or is convertible to a UTF-8 encoded string.
// This function may only be called from the main thread.
func glfwGetClipboardString() string {
	b := clipboard.Read(clipboard.FmtText)
	return string(b)
}

// SetClipboardString sets the system clipboard to the specified UTF-8 encoded string.
// This function may only be called from the main thread.
func glfwSetClipboardString(str string) {
	clipboard.Write(clipboard.FmtText, []byte(str))
}

func monitorFromWindow(handle syscall.Handle, flags uint32) syscall.Handle {
	r1, _, err := _MonitorFromWindow.Call(uintptr(handle), uintptr(flags))
	if err != nil && !errors.Is(err, syscall.Errno(0)) {
		panic("MonitorFromWindow failed, " + err.Error())
	}
	return syscall.Handle(r1)
}

func glfwGetContentScale(w *Window) (float32, float32) {
	var xscale, yscale float32
	var xdpi, ydpi int
	handle := monitorFromWindow(w.Win32.handle, MONITOR_DEFAULTTONEAREST)
	if IsWindows8Point1OrGreater() {
		_, _, err := _GetDpiForMonitor.Call(uintptr(handle), uintptr(0),
			uintptr(unsafe.Pointer(&xdpi)), uintptr(unsafe.Pointer(&ydpi)))
		if !errors.Is(err, syscall.Errno(0)) {
			panic("GetDpiForMonitor failed, " + err.Error())
		}
	} else {
		dc := getDC(0)
		xdpi = GetDeviceCaps(dc, LOGPIXELSX)
		ydpi = GetDeviceCaps(dc, LOGPIXELSY)
		releaseDC(0, dc)
	}
	xscale = float32(xdpi) / USER_DEFAULT_SCREEN_DPI
	yscale = float32(ydpi) / USER_DEFAULT_SCREEN_DPI
	return xscale, yscale
}

func glfwGetWindowMonitor(window *Window) *Monitor {
	return window.monitor
}

func glfwSetWindowMonitor(window *Window, monitor *Monitor, xpos int, ypos int, width int, height int, refreshRate int) {
	if width <= 0 || height <= 0 {
		panic("glfwSetWindowMonitor: invalid width or height")
	}
	window.videoMode.Width = width
	window.videoMode.Height = height
	window.videoMode.RefreshRate = refreshRate
	// This is _glfw.platform.setWindowMonitor(window, monitor, xpos, ypos, width, height,	RefreshRate);
	if window.monitor == monitor {
		if monitor != nil {
			if monitor.window == window {
				acquireMonitor(window)
				fitToMonitor(window)
			}
		} else {
			rect := RECT{int32(xpos), int32(ypos), int32(xpos + width), int32(ypos + height)}
			if IsWindows10Version1607OrGreater() {
				AdjustWindowRectExForDpi(&rect, getWindowStyle(window), 0, getWindowExStyle(window), GetDpiForWindow(window.Win32.handle))
			} else {
				AdjustWindowRectEx(&rect, getWindowStyle(window), 0, getWindowExStyle(window))
			}
			_, _, err := _SetWindowPos.Call(uintptr(window.Win32.handle), 0 /* HWND_TOP*/, uintptr(rect.Left), uintptr(rect.Top),
				uintptr(rect.Right-rect.Left), uintptr(rect.Bottom-rect.Top), uintptr(SWP_NOCOPYBITS|SWP_NOACTIVATE|SWP_NOZORDER))
			if err != nil && !errors.Is(err, syscall.Errno(0)) {
				panic("SetWindowPos failed, " + err.Error())
			}
		}
		return
	}

	if window.monitor != nil {
		releaseMonitor(window)
	}
	// _glfwInputWindowMonitor(monitor, window)
	window.monitor = monitor

	if window.monitor != nil {
		flags := SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOCOPYBITS
		if window.decorated {
			style := GetWindowLongW(window.Win32.handle, GWL_STYLE)
			style &= ^uint32(WS_OVERLAPPEDWINDOW)
			style |= getWindowStyle(window)
			SetWindowLongW(window.Win32.handle, GWL_STYLE, style)
			flags |= SWP_FRAMECHANGED
		}
		acquireMonitor(window)
		mi := GetMonitorInfo(window.monitor.hMonitor)
		SetWindowPos(window.Win32.handle, HWND_TOPMOST,
			mi.RcMonitor.Left, mi.RcMonitor.Top,
			mi.RcMonitor.Right-mi.RcMonitor.Left, mi.RcMonitor.Bottom-mi.RcMonitor.Top,
			SWP_NOCOPYBITS|SWP_NOACTIVATE|SWP_NOZORDER)
	} else {
		rect := RECT{int32(xpos), int32(ypos), int32(xpos + width), int32(ypos + height)}
		style := GetWindowLongW(window.Win32.handle, GWL_STYLE)
		flags := SWP_NOACTIVATE | SWP_NOCOPYBITS
		if window.decorated {
			style = style &^ uint32(WS_POPUP)
			style |= getWindowStyle(window)
			SetWindowLongW(window.Win32.handle, GWL_STYLE, style)
			flags |= SWP_FRAMECHANGED
			style = getWindowStyle(window)
		}
		after := syscall.Handle(HWND_NOTOPMOST)
		if window.floating {
			after = syscall.Handle(HWND_TOPMOST)
		}

		if IsWindows10Version1607OrGreater() {
			AdjustWindowRectExForDpi(&rect, getWindowStyle(window), 0, getWindowExStyle(window), GetDpiForWindow(window.Win32.handle))
		} else {
			AdjustWindowRectEx(&rect, getWindowStyle(window), 0, getWindowExStyle(window))
		}
		SetWindowPos(window.Win32.handle, after, rect.Left, rect.Top, rect.Right-rect.Left, rect.Bottom-rect.Top, SWP_NOCOPYBITS|SWP_NOACTIVATE|SWP_NOZORDER)
	}
}

func glfwPollMonitors() {
	/* disconnectedCount := _glfw.monitorCount;
	if (disconnectedCount) {
		disconnected = _glfw_calloc(_glfw.monitorCount, sizeof(Monitor*));
		memcpy(disconnected, _glfw.monitors, _glfw.monitorCount * sizeof(Monitor*));
	} */
	// var disconnected []*Monitor = _glfw.monitors

	for adapterIndex := 0; adapterIndex < 1000; adapterIndex++ {
		var adapter DISPLAY_DEVICEW
		adapterType := GLFW_INSERT_LAST
		adapter.cb = uint32(unsafe.Sizeof(adapter))
		EnumDisplayDevices(0, adapterIndex, &adapter, 0)

		if (adapter.StateFlags & DISPLAY_DEVICE_ACTIVE) == 0 {
			continue
		}

		if (adapter.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) != 0 {
			adapterType = GLFW_INSERT_FIRST
		}
		for displayIndex := 0; ; displayIndex++ {
			var display DISPLAY_DEVICEW
			display.cb = uint32(unsafe.Sizeof(display))
			if !EnumDisplayDevices(uintptr(unsafe.Pointer(&adapter.DeviceName)), displayIndex, &display, 0) {
				break
			}

			if (display.StateFlags & DISPLAY_DEVICE_ACTIVE) == 0 {
				continue
			}
			monitor := createMonitor(&adapter, &display)
			if monitor == nil {
				return
			}

			glfwInputMonitor(monitor, GLFW_CONNECTED, adapterType)
			adapterType = GLFW_INSERT_LAST

			// HACK: If an active adapter does not have any display devices
			//       (as sometimes happens), add it directly as a monitor
			/*
				if displayIndex == 0 {
					for i := 0; i < disconnectedCount; i++ {
						if disconnected[i] && wcscmp(disconnected[i].win32.adapterName, adapter.DeviceName) == 0 {
							disconnected[i] = NULL
							break
						}
					}
				}
				if i < disconnectedCount {
					continue
				}

				monitor = createMonitor(&adapter, NULL)
				if monitor == nil {
					_glfw_free(disconnected)
					return
				}
			*/
			// glfwInputMonitor(monitor, GLFW_CONNECTED, adapterType)
		}
		/*
			for i := 0; i < disconnectedCount; i++ {
				if disconnected[i] {
					glfwInputMonitor(disconnected[i], GLFW_DISCONNECTED, 0)
				}
			}
		*/
	}
}

func LoadCursor(cursorID uint16) HANDLE {
	h, err := LoadImage(0, uint32(cursorID), IMAGE_CURSOR, 0, 0, LR_DEFAULTSIZE|LR_SHARED)
	if err != nil && !errors.Is(err, syscall.Errno(0)) {
		panic("LoadCursor failed, " + err.Error())
	}
	if h == 0 {
		panic("LoadCursor failed")
	}
	return HANDLE(h)
}

func glfwSetWindowSize(window *Window, width, height int) {
	rect := RECT{0, 0, int32(width), int32(height)}
	AdjustWindowRect(&rect, getWindowStyle(window), 0, getWindowExStyle(window), GetDpiForWindow(window.Win32.handle), "glfwSetWindowSize")
	SetWindowPos(window.Win32.handle, 0, 0, 0, rect.Right-rect.Left, rect.Bottom-rect.Top, SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOMOVE|SWP_NOZORDER)
}

func AdjustWindowRect(rect *RECT, style uint32, menu int, exStyle uint32, dpi int, from string) {
	if IsWindows10Version1607OrGreater() {
		AdjustWindowRectExForDpi(rect, style, 0, exStyle, dpi)
	} else {
		AdjustWindowRectEx(rect, style, 0, exStyle)
	}
}
